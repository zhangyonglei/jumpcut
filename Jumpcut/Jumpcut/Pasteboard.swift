//
//  Pasteboard.swift
//  Jumpcut
//
//  Created by Steve Cook on 10/4/20.
//

import AppKit
import Sauce

class Pasteboard {
    private let internalPasteboardType = NSPasteboard.PasteboardType(rawValue: "net.sf.jumpcut.internal")
    private let nspbSource = NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.source")
    private let gpb = NSPasteboard.general
    var lastFound: String?
    private var changeCallback: () -> Void
    private let interval = 0.5
    private var changeCount: Int = -1

    private let transientTypes = [
        NSPasteboard.PasteboardType("de.petermaurer.TransientPasteboardType"),
        NSPasteboard.PasteboardType("com.typeit4me.clipping"),
        NSPasteboard.PasteboardType("Pasteboard generator type"),
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    ]
    private let sensitiveTypes = [
        NSPasteboard.PasteboardType("PasswordPboardType"),
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("com.agilebits.onepassword")
    ]

    public init(changeCallback: @escaping () -> Void) {
        changeCount = self.gpb.changeCount
        self.changeCallback = changeCallback

        Timer.scheduledTimer(timeInterval: interval,
                             target: self,
                             selector: #selector(pollPasteboard),
                             userInfo: nil,
                             repeats: true)
    }

    public func set(_ text: String, autogenerated: Bool = false) {
        let gpb = NSPasteboard.general
        gpb.clearContents()
        gpb.setString(text, forType: .string)
        gpb.setString("1", forType: internalPasteboardType)
        // We do not track the original source of the clipping, so we cannot report it here.
        gpb.setString("", forType: nspbSource)
        if autogenerated {
            // Used e.g. when clearing the stack; we don't want any applications
            // which track the stack to adjust the new item.
            gpb.setString(
                "1",
                forType: NSPasteboard.PasteboardType(rawValue: "org.nspasteboard.AutoGeneratedType")
            )
        }
    }

    public func topItem() -> String? {
        NSPasteboard.general.pasteboardItems?.first?.string(forType: .string)
    }

    @objc
    private func pollPasteboard() {
        // Short-circuit our tests without examining the string or the pasteboard at all,
        // if it doesn't seem like there's been an update.
        guard gpb.changeCount != changeCount else {
            return
        }
        changeCount = gpb.changeCount
        var found: String?
        for item in (gpb.pasteboardItems!) {
            /*
             We have a number of possible cases where we don't want to trigger our
             hooks. (For details about nos. 3 and 4, see nspasteboard.org.)
             1. The clipping is nil.
             2. The clipping is whitespace.
             3. It's *transient*, indicating that it's a automatically-generated
             item such as a macro expansion from an application like TextExpander.
             4. It's *sensitive*, indicating that it came from a password manager.
             Note that this check may be overridden.
             5. The clipping is too big. Note that this check may be overriden.
             6. The clipping already came from Jumpcut.
             There are additional cases where we don't want to add to the stack, which
             are outside the pasteboard listener's scope:
             1. The clippping is already on the stack. (For instance, it was saved,
             then Jumpcut was quit and relaunched, or another application has updated
             the pasteboard to remove a transient change, or it was present when the
             stack was cleared, or the user simply copied twice.)
             */
            let ignoreSensitive = UserDefaults.standard.bool(forKey: SettingsPath.ignoreSensitiveClippingTypes.rawValue)
            let ignoreLarge = UserDefaults.standard.bool(forKey: SettingsPath.ignoreLargeClippings.rawValue)
            let allowWhitespace = UserDefaults.standard.value(
                forKey: SettingsPath.allowWhitespaceClippings.rawValue
            ) as? Bool ?? false
            if let itemString = item.string(forType: .string) {
                if
                    (allowWhitespace || !itemString.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty) &&
                    item.types.filter(transientTypes.contains).count == 0 &&
                    (!ignoreSensitive || item.types.filter(sensitiveTypes.contains).count == 0) &&
                    (!ignoreLarge || itemString.count <= 50000) &&
                    item.string(forType: NSPasteboard.PasteboardType("net.sf.jumpcut.internal")) != "1" {
                        found = itemString
                        break
                }
            }
        }
        if found != nil {
            lastFound = found
            self.changeCallback()
        }
    }

    func fakeCommandV() {
        let sourceRef = CGEventSource(stateID: .combinedSessionState)
        guard sourceRef != nil else {
            return
        }
        // Disable local hardware keyboard events
        sourceRef!.setLocalEventsFilterDuringSuppressionState(
            [.permitLocalMouseEvents, .permitSystemDefinedEvents],
            state: .eventSuppressionStateSuppressionInterval)
        let veeCode = Sauce.shared.keyCode(for: .v)
        sourceRef!.setLocalEventsFilterDuringSuppressionState(
            [.permitLocalMouseEvents, .permitSystemDefinedEvents],
            state: .eventSuppressionStateSuppressionInterval)
        let eventDown = CGEvent(keyboardEventSource: sourceRef, virtualKey: veeCode, keyDown: true)
        eventDown?.flags = .maskCommand
        let eventUp = CGEvent(keyboardEventSource: sourceRef, virtualKey: veeCode, keyDown: false)
        eventUp?.flags = .maskCommand
        eventDown?.post(tap: .cgAnnotatedSessionEventTap)
        eventUp?.post(tap: .cgAnnotatedSessionEventTap)
    }

}
